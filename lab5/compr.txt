
// entropy 
package javaapplication4;

import java.io.*;
import java.util.HashMap;

public class Main {

    public static void main(String[] args) {
        HashMap<Character, Integer> hmap = new HashMap<Character, Integer>();
        File file = new File("C:/Users/User7/Desktop/NewFolder/file.txt");
        char[] chars = new char[(int) file.length()];
        try {
           FileReader reader = new FileReader(file);
           reader.read(chars);
           reader.close();
        } catch (IOException e) {
           System.out.println(e.getMessage());
        }

     
        for (int i = 0; i < chars.length; i++) {
            if (hmap.containsKey(chars[i])) {
                 hmap.put(chars[i], hmap.get(chars[i]) + 1);
            } else {
                 hmap.put(chars[i], 1);
            }
        }

        for (Character key : hmap.keySet()) {
            System.out.println(key + ": "
                    + hmap.get(key)/(float)chars.length * 100 + "%");
       }
       double entropy = entropyc(hmap, chars.length);
       double redundancy = Log2(256) - entropy;
       double efficiency = entropy / Log2(256);
       System.out.println("Entropy: " + entropy);
       System.out.println("Redundancy: " + redundancy);
       System.out.println("Efficiency: " + efficiency);

       double prob = 0.0;
       for (Character key : hmap.keySet()) {
            prob += hmap.get(key)/(float)chars.length;
       }

       System.out.println();
       System.out.println(prob);

       System.out.println("---------------------------");
       System.out.println();
       
        HashMap<Byte, Integer> hmap2 = new HashMap<Byte, Integer>();
        File filebin = new File("C:/Users/User7/Desktop/NewFolder/flower.bmp");
        byte[] binData = new byte [(int)filebin.length()];
        try {
           FileInputStream reader = new FileInputStream(filebin);
           reader.read(binData);
           reader.close();
        } catch (IOException e) {
           System.out.println(e.getMessage());
        }

       
        for (int i = 0; i < binData.length; i++) {
            if (hmap2.containsKey(binData[i])) {
                 hmap2.put(binData[i], hmap2.get(binData[i]) + 1);
            } else {
                 hmap2.put(binData[i], 1);
            }
        }


        for (Byte key : hmap2.keySet()) {
            System.out.println(key + ": "
                    + hmap2.get(key)/(float)binData.length * 100 + "%");
        }

         double entropybin = entropy(hmap2, binData.length);
         double redundancybin = Log2(2) - entropybin;
         double efficiencybin = entropybin / Log2(2);
         System.out.println("Entropy: " + entropybin);
         System.out.println("Redundancy: " + redundancybin);
         System.out.println("Efficiency: " + efficiencybin);
         System.out.println();

         double probbin = 0.0;
         for (Byte key : hmap2.keySet()) {
            probbin += hmap2.get(key)/(float)binData.length;
        }
        System.out.println(probbin);
    }

    private static double entropy(HashMap<Byte, Integer> hmap, int length) {
        double entropy = 0;
        for (Byte key : hmap.keySet()) {
             double prob = (double) hmap.get(key)/length;
             entropy -= prob * Log2(prob);
        }
        return entropy;
    }

     private static double entropyc(HashMap<Character, Integer> hmap, int length) {
        double entropy = 0;
        for (Character key : hmap.keySet()) {
             double prob = (double) hmap.get(key)/length;
             entropy -= prob * Log2(prob);
        }
        return entropy;
    }

    private static double Log2(double n) {
           return Math.log(n) / Math.log(2);
    }

}


// Huffman

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.Comparator;

class HuffmanNode {

    int data;
    char c;

    HuffmanNode left;
    HuffmanNode right;
}

class MyComparator implements Comparator<HuffmanNode> {
    public int compare(HuffmanNode x, HuffmanNode y)
    {

        return x.data - y.data;
    }
}

public class Huffman {
    public static void printCode(HuffmanNode root, String s)
    {
        if (root.left == null && root.right == null
                && (Character.isLetter(root.c) || root.c == ' ')) {

            System.out.println(root.c + ":" + s);

            return;
        }

        // daca mergem stanga adaugam "0"
        // daca mergem dreapta adaugam "1"
        printCode(root.left, s + "0");
        printCode(root.right, s + "1");
    }

    public static void main(String[] args)
    {

        HashMap<Character, Integer> hmap = new HashMap<Character, Integer>();
        File file = new File("./file.txt");
        char[] chars = new char[(int) file.length()];
        try {
            FileReader reader = new FileReader(file);
            reader.read(chars);
            reader.close();
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }


        for (int i = 0; i < chars.length; i++) {
            if (hmap.containsKey(chars[i])) {
                hmap.put(chars[i], hmap.get(chars[i]) + 1);
            } else {
                hmap.put(chars[i], 1);
            }
        }

        for (Character key : hmap.keySet()) {
            System.out.println(key + ": "
                    + hmap.get(key)/(float)chars.length * 100 + "%");
        }

        PriorityQueue<HuffmanNode> q
                = new PriorityQueue<HuffmanNode>(hmap.size(), new MyComparator());

        for (Character key : hmap.keySet()) {

            HuffmanNode hn = new HuffmanNode();

            hn.c = key;
            hn.data = hmap.get(key);

            hn.left = null;
            hn.right = null;

            q.add(hn);
        }

        HuffmanNode root = null;


        // Aici vom extrage cele douÄƒ valori minime
        while (q.size() > 1) {

            // prima min val
            HuffmanNode x = q.peek();
            q.poll();

            // a doua
            HuffmanNode y = q.peek();
            q.poll();

            HuffmanNode f = new HuffmanNode();

            // suma celor doua noduri
            f.data = x.data + y.data;
            f.c = '-';

            f.left = x;
            f.right = y;

            root = f;

            q.add(f);
        }

        // print
        printCode(root, "");
    }
}



// Cod Hamming
import java.util.Scanner;


public class Hamming {

    public static void main(String[] args) {
        Scanner ip = new Scanner(System.in);
        System.out.print("Mesaj: "); // eg. 1001
        String msg = ip.next();
        int r = 0, m = msg.length();
        // calculam numarul de biti de paritate necesar folosind m+r+1<=2^r
        while (true) {
            if (m + r + 1 <= Math.pow(2, r)) {
                break;
            }
            r++;
        }
        System.out.println("Nr. de biti de paritate necesar: " + r);
        int transLength = msg.length() + r, temp = 0, temp2 = 0, j = 0;
        int transMsg[] = new int[transLength + 1]; //+1 pt ca incepe cu 1
        for (int i = 1; i <= transLength; i++) {
            temp2 = (int) Math.pow(2, temp);
            if (i % temp2 != 0) {
                transMsg[i] = Integer.parseInt(Character.toString(msg.charAt(j)));
                j++;
            } else {
                temp++;
            }
        }
        for (int i = 1; i <= transLength; i++) {
            System.out.print(transMsg[i]);
        }
        System.out.println();

        for (int i = 0; i < r; i++) {
            int smallStep = (int) Math.pow(2, i);
            int bigStep = smallStep * 2;
            int start = smallStep, checkPos = start;
            System.out.println("Calculam bit-ul de paritate pt. pozitia: " + smallStep);
            System.out.print("Biti de verificat: ");
            while (true) {
                for (int k = start; k <= start + smallStep - 1; k++) {
                    checkPos = k;
                    System.out.print(checkPos + " ");
                    if (k > transLength) {
                        break;
                    }
                    transMsg[smallStep] ^= transMsg[checkPos];
                }
                if (checkPos > transLength) {
                    break;
                } else {
                    start = start + bigStep;
                }
            }
            System.out.println();
        }

        System.out.print("Codul Hamming: ");
        for (int i = 1; i <= transLength; i++) {
            System.out.print(transMsg[i]);
        }
        System.out.println();
    }

}
