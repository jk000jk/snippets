tap

// 1

#include <iostream>
#include <fstream>
#include "iomanip.h"

using namespace std;

struct Obj {
	int id;
	float c, g;
};

bool cmpObj(Obj x, Obj y) {
	return x.c/x.g > y.c/y.g;
}


// n objects (g1-weight, c1-value), G weight
// continue (orice obj can be cu) O(n log(n)) and discret objects can't be cut dynamic O(n * G) or backtraking. O(2^n)
int main() {
	Obj *v;
	int i, n;
	float p, ct, G;
	
	ifstream fin("obj.txt");
	ofstream fout("r.txt");
	
	fin >> G;
	fin >> n;
	
	v = new Obj[n];
	
	for (i = 0; i < n; i++) {
		v[i].id = i+1;
		fin >> v[i].c >> v[i].g;	
	}
	fin.close();
	
	sort(v, v+n, cmpObj);
	
	ct = 0;
	for (i = 0; i < n; i++) {
		if (v[i].g <= G) {
			fout << "Obj " << v[i].id << " 100%" << endl;
			G = G - v[i].g;
			ct = ct + v[i].c;
		} else {
			p = G / v[i].g;
			fout << "Obj " << v[i].id << " " << setprecision(2) << p * 100 << "%" << endl;
			ct = ct + p*v[i].c;
			break;
		}
	}
	
	fout << ct;
	fout.close();
	
	delete []v;
	
	return 0;
}



// oop 
// 1

#include <iostream>
#include <math.h>
using namespace std;

class Complex {
	double re, im;
public:
	Complex() {
		re = 0;
		im = 0;
	}		
	Complex(double re, double im) {
		this->re = re;
		this->im = im;
	}
	
	void afisare() {
		cout << re << "+" << im << "i" << endl;
	}
	
	Complex operator+(Complex z){
		Complex suma;
		suma.re = this->re + z.re;
		suma.im = this->im + z.im;
		return suma;
	}
	
	friend double modul(Complex &ob);
};

double modul(Complex &ob){
	return sqrt(ob.re * ob.re + ob.im * ob.im);
}


int main() {
	Complex z1(2, 3), z2(3, 4), z3;
	z3 = z1 + z2;
	
 	z3.afisare();
	
	// cout << modul(z1);
	
	return 0;	
}


// tap 

#include <fstream>
#include <iostream>
#include <algorithm>
#include <iomanip>

using namespace std;

struct Spectacol
{
    char nume[100];
    int hi, mi, hf, mf;
};

bool cmpSpectacole(Spectacol a, Spectacol b)
{
    return a.hf*60+a.mf < b.hf*60+b.mf;
}

int main()
{
    int i, n, ult;
    Spectacol *sp;
    char c;

    ifstream fin("spectacole.txt");
    fin >> n;
    sp = new Spectacol[n];

    for(i = 0; i < n; i++)
    {
        fin >> sp[i].hi >> c >> sp[i].mi >> c >> sp[i].hf >> c >> sp[i].mf;
        fin.getline(sp[i].nume, 100);
    }

    fin.close();

    sort(sp, sp+n, cmpSpectacole);

    ofstream fout("programare.txt");

    fout << setfill('0') << setw(2) << sp[0].hi << ":" << setfill('0') << setw(2) << sp[0].mi << "-" << setfill('0') << setw(2) << sp[0].hf << ":" << setfill('0') << setw(2) << sp[0].mf << " " << sp[0].nume << endl;

    ult = sp[0].hf*60 + sp[0].mf;

    for(i = 1; i < n; i++)
        if(sp[i].hi*60 + sp[i].mi > ult)
        {
            fout << setfill('0') << setw(2) << sp[i].hi << ":" << setfill('0') << setw(2) << sp[i].mi << "-" << setfill('0') << setw(2) << sp[i].hf << ":" << setfill('0') << setw(2) << sp[i].mf << " " << sp[i].nume << endl;
            ult = sp[i].hf*60 + sp[i].mf;
        }

    fout.close();

    return 0;
}
