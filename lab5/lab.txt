tap

// 1

#include <iostream>
#include <fstream>
#include "iomanip.h"

using namespace std;

struct Obj {
	int id;
	float c, g;
};

bool cmpObj(Obj x, Obj y) {
	return x.c/x.g > y.c/y.g;
}


// n objects (g1-weight, c1-value), G weight
// continue (orice obj can be cu) O(n log(n)) and discret objects can't be cut dynamic O(n * G) or backtraking. O(2^n)
int main() {
	Obj *v;
	int i, n;
	float p, ct, G;
	
	ifstream fin("obj.txt");
	ofstream fout("r.txt");
	
	fin >> G;
	fin >> n;
	
	v = new Obj[n];
	
	for (i = 0; i < n; i++) {
		v[i].id = i+1;
		fin >> v[i].c >> v[i].g;	
	}
	fin.close();
	
	sort(v, v+n, cmpObj);
	
	ct = 0;
	for (i = 0; i < n; i++) {
		if (v[i].g <= G) {
			fout << "Obj " << v[i].id << " 100%" << endl;
			G = G - v[i].g;
			ct = ct + v[i].c;
		} else {
			p = G / v[i].g;
			fout << "Obj " << v[i].id << " " << setprecision(2) << p * 100 << "%" << endl;
			ct = ct + p*v[i].c;
			break;
		}
	}
	
	fout << ct;
	fout.close();
	
	delete []v;
	
	return 0;
}



// oop 
// 1

#include <iostream>
#include <math.h>
using namespace std;

class Complex {
	double re, im;
public:
	Complex() {
		re = 0;
		im = 0;
	}		
	Complex(double re, double im) {
		this->re = re;
		this->im = im;
	}
	
	void afisare() {
		cout << re << "+" << im << "i" << endl;
	}
	
	Complex operator+(Complex z){
		Complex suma;
		suma.re = this->re + z.re;
		suma.im = this->im + z.im;
		return suma;
	}
	
	friend double modul(Complex &ob);
};

double modul(Complex &ob){
	return sqrt(ob.re * ob.re + ob.im * ob.im);
}


int main() {
	Complex z1(2, 3), z2(3, 4), z3;
	z3 = z1 + z2;
	
 	z3.afisare();
	
	// cout << modul(z1);
	
	return 0;	
}


// tap 

#include <fstream>
#include <iostream>
#include <algorithm>
#include <iomanip>

using namespace std;

struct Spectacol
{
    char nume[100];
    int hi, mi, hf, mf;
};

bool cmpSpectacole(Spectacol a, Spectacol b)
{
    return a.hf*60+a.mf < b.hf*60+b.mf;
}

int main()
{
    int i, n, ult;
    Spectacol *sp;
    char c;

    ifstream fin("spectacole.txt");
    fin >> n;
    sp = new Spectacol[n];

    for(i = 0; i < n; i++)
    {
        fin >> sp[i].hi >> c >> sp[i].mi >> c >> sp[i].hf >> c >> sp[i].mf;
        fin.getline(sp[i].nume, 100);
    }

    fin.close();

    sort(sp, sp+n, cmpSpectacole);

    ofstream fout("programare.txt");

    fout << setfill('0') << setw(2) << sp[0].hi << ":" << setfill('0') << setw(2) << sp[0].mi << "-" << setfill('0') << setw(2) << sp[0].hf << ":" << setfill('0') << setw(2) << sp[0].mf << " " << sp[0].nume << endl;

    ult = sp[0].hf*60 + sp[0].mf;

    for(i = 1; i < n; i++)
        if(sp[i].hi*60 + sp[i].mi > ult)
        {
            fout << setfill('0') << setw(2) << sp[i].hi << ":" << setfill('0') << setw(2) << sp[i].mi << "-" << setfill('0') << setw(2) << sp[i].hf << ":" << setfill('0') << setw(2) << sp[i].mf << " " << sp[i].nume << endl;
            ult = sp[i].hf*60 + sp[i].mf;
        }

    fout.close();

    return 0;
}


// oop 
// 1

class Fractie {
	int nr, num;
public:	
	Fractie();
	Fractie(int nr, int num);
	void afisare();
	void setNr(int v);
	void setNum(int v);
	int getNr();
	int getNum();
	Fractie operator+(Fractie f2);
	friend Fractie operator*(Fractie f1, Fractie f2);
	friend Fractie operator*(int v, Fractie f);
	Fractie& operator~();
};


# include <iostream>
# include "Fractie.h"

using namespace std;
 
Fractie::Fractie() {
	nr = 0;
	num = 1;
}

Fractie::Fractie(int nr, int num) {
	this->nr = nr;
	this->num = num;
}

void Fractie::afisare() {
	cout << nr << "/" << num << endl;
}

void Fractie::setNr(int v) {
	nr = v;
}

void Fractie::setNum(int v) {
	num = v;
}

int Fractie::getNr() {
	return nr;
}

int Fractie::getNum() {
	return num;
}

Fractie Fractie::operator+(Fractie f2) {
	Fractie suma;
	suma.nr = this->nr * f2.num + this->num * f2.nr;
	suma.num = this->num * f2.num;
	
	return suma;	
}

Fractie operator*(Fractie f1, Fractie f2) {
	Fractie produs;
	produs.nr = f1.nr * f2.nr;
	produs.num = f2.num * f2.num;
	
	return produs;
}

Fractie operator*(int v, Fractie f) {
	Fractie produs;
	produs.nr = v * f.nr;
	produs.num = f.num;
	
	return produs;
}
int cmmdc(int a, int b) {
   int c = a % b;
	while (b) {
		c = a % b;
		a = b;
		b = c;
	}
	return c;
}

Fractie& Fractie::operator~() {
	 int d = cmmdc(this->nr, this->num);
	 this->nr = this->nr / d;
	 this->num = this->num / d;
	 
	 return *this;
}

# include <iostream>
# include "fractie.h"

using namespace std;



int main() {
	Fractie f1(3, 4), f2(2, 5), f3;
	
	f3 = f1 + f2;
	
	f3.afisare();
	
	return 0;
}

// 2

cass Farmacie {
	char *den;
	int nrAngajati;
	int nrLuni;
	double CaLuna;
	const int id;
public:
	Farmacie();
	Farmacie(char *den, int nrAngajati, int nrLuni, double *CaLuna);
	Farmacie(const Farmacie &ob);
	~Farmacie();
	char* getDen();
	int getNrAngajati();
	int getNrLuni();
	double* getCaLuna();
	void afisare();
	Farmacie& operator=(const Farmacie &ob);
	Farmacie& operator+(int v);
	Farmacie& operator++();
	Farmacie operator++(int v);
};

# include <iostream>
# include "Farmacie.h"

using namespace std;

Farmacie& Farmacie::operator=(const Farmacie &ob) {
	if (den)
			delete[] den;
	if (CaLuna)
			delete[] CaLuna;
	
	this->den = new char[strlen(ob.den)+1];
	strcpy(this->den, ob.den);
	this->nrAngajati = ob.nrAngajati;
	this->nrLuni =  ob.nrLuni;
	this->CaLuna = new double[nrLuni];
	for (int i = 0; i < nrLuni; i++) {
		this->caLuna[i] = ob.CaLuna[i]
	}
}
