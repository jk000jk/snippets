/*
 * GLUT Shapes Demo
 *
 * Written by Nigel Stewart November 2003
 *
 * This program is test harness for the sphere, cone
 * and torus shapes in GLUT.
 *
 * Spinning wireframe and smooth shaded shapes are
 * displayed until the ESC or q key is pressed.  The
 * number of geometry stacks and slices can be adjusted
 * using the + and - keys.
 */

#ifdef __APPLE__
#include <GLUT/glut.h>
#else
#include <GL/glut.h>
#endif

#include <stdlib.h>


void display() {
   glClear(GL_COLOR_BUFFER_BIT);
   glColor3d(0, 1, 1);
   glBegin(GL_POLYGON);
        glVertex2f(250, 300);
        glVertex2f(350, 300);
        glVertex2f(400, 400);
        glVertex2f(300, 500);
        glVertex2f(200, 400);
   glEnd();
   glFlush();

   glBegin(GL_LINES);
   glColor3d(1, 1, 1);
        glVertex2f(0, 300);
        glVertex2f(450, 300);
        glVertex2f(200, 300);
        glVertex2f(200, 500);
   glEnd();
   glFlush();

   glColor3d(0, 1, 0);
   glBegin(GL_POLYGON);
        glVertex2f(250, 300);
        glVertex2f(350, 300);
        glVertex2f(400, 200);
        glVertex2f(300, 100);
        glVertex2f(200, 200);
   glEnd();
   glFlush();

  glColor3d(1, 0, 0);
   glBegin(GL_POLYGON);
        glVertex2f(50, 300);
        glVertex2f(150, 300);
        glVertex2f(200, 400);
        glVertex2f(100, 500);
        glVertex2f(0, 400);
   glEnd();
   glFlush();


}
void reshape (int w, int h)//functia redesenare
{
    glViewport (0, 0, (GLsizei) w, (GLsizei) h);//stabilirea viewportului la dimensiunea ferestrei
    glMatrixMode (GL_PROJECTION);//specificare matrice modificabila la valoare argumentului de modificare
    glLoadIdentity ();//initializarea sistemului de coordonate
    gluOrtho2D (0.0, (GLdouble) w, 0.0, (GLdouble) h);//stabileste volumul de vedere folosind o proiectie ortografica
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
    glutInitWindowSize (800, 800);
    glutInitWindowPosition (150,150);
    glutCreateWindow ("Chelaru Marius Gr. 201");
    glutDisplayFunc(display); glutReshapeFunc(reshape);
    glutMainLoop();

    return 0;
}



// oop

#include <iostream>
#include <stack>

using namespace std;


int main() {
    stack<int> baza;
	int n;
	
	cout << "n = ";
	cin >> n;
	
	while (n) {
		baza.push(n%2);
		n = n/2;
	}
	
	while (!baza.empty()) {
		cout << baza.top();
		baza.pop();
	}
	return 0;
}


#include <iostream>

using namespace std;

class Punct {
	double x, y;
public:
	Punct();
	Punct(double x, double y);
	
	friend ostream& operator <<(ostream& out, Punct ob);	
	bool operator< (Punct p);
	
	void setX(double x);
	void setY(double y);
	double getX();
	double getY();
};


#include <iostream>
#include "Punct.h"

using namespace std;

Punct::Punct() {
	x = 0;
	y = 0;
}

Punct::Punct(double x, double y) {
	this->x = x;
	this->y = y;
}

ostream& operator<<(ostream& out, Punct ob) {
	out << ob.x << " " << ob.y << endl;
	return out;
}


bool Punct::operator<(Punct p) {
	if (this->x == p.x) {
		return this->y < p.y;
	} else {
		return this->x < p.x;
	}
}

void Punct::setX(double x) {
	this->x = x;
}

void Punct::setY(double y) {
	this->y = y;
}

double Punct::getX() {
	return x;
}

double Punct::getY() {
	return y;
}

#include <iostream>
#include "Punct.h"
#include <vector>
#include <algorithm>
#include <fstream>

using namespace std;

bool comp(Punct p1, Punct p2) {
	return p1 < p2;
}

int main() {
	vector <Punct> vp;
	double x,y;

	ifstream f("Punct.txt");

	while (f >> x >> y) {
		Punct ob(x, y);
		vp.push_back(ob);
	}		
	
	sort(vp.begin(), vp.end(), comp);
	
	vector<Punct>::iterator it;
	for (it = vp.begin(); it != vp.end(); it++) {
		cout << *it;
	}
	
	return 0;
}


#include <iostream>
#include <string>
#include <fstream>
#include <map>
#include <string.h>
#include <algorithm>

using namespace std;
 
int main() {
	map<string, string> agenda;
	ifstream f("agenda.txt");
	char linie[100], *p;	
	string nume, nrTel;
	char numecautat[30];
	
	while (f.getline(linie, 100) != NULL) {
		p = strtok(linie, " ");
		nume = p;
		p = strtok(NULL, " ");
		nrTel = p;
		agenda.insert(make_pair(nume, nrTel));
	}
	cout << "Nume: ";
	cin >> numecautat;
	nume =  numecautat;
	
	map<string, string>::iterator it;
	it = find(agenda.begin(), agenda.end(), nume);
	if (it != NULL) {
		cout << "Tel: " << (*it).second;
	} else {
		cout << "No";
	}
	
	for (it = agenda.begin(); it != agenda.end(); it++) {
		cout << (*it).first << " " << (*it).second << endl;	
	}
	
	return 0;
}
