// oop 

cass Farmacie {
	char *den;
	int nrAngajati;
	int nrLuni;
	double CaLuna;
	const int id;
public:
	Farmacie();
	Farmacie(char *den, int nrAngajati, int nrLuni, double *CaLuna);
	Farmacie(const Farmacie &ob);
	~Farmacie();
	char* getDen();
	int getNrAngajati();
	int getNrLuni();
	double* getCaLuna();
	void afisare();
	Farmacie& operator=(const Farmacie &ob);
	Farmacie& operator+(int v);
	Farmacie& operator++();
	Farmacie operator++(int v);
};

# include <iostream>
# include "Farmacie.h"

using namespace std;

Farmacie& Farmacie::operator=(const Farmacie &ob) {
	if (den)
			delete[] den;
	if (CaLuna)
			delete[] CaLuna;
	
	this->den = new char[strlen(ob.den)+1];
	strcpy(this->den, ob.den);
	this->nrAngajati = ob.nrAngajati;
	this->nrLuni =  ob.nrLuni;
	this->CaLuna = new double[nrLuni];
	for (int i = 0; i < nrLuni; i++) {
		this->caLuna[i] = ob.CaLuna[i]
	}
}



// Graphics 

#include "stdafx.h"
#include <gl/freeglut.h>
#include<math.h>

void display()
{
	glClear(GL_COLOR_BUFFER_BIT);
	glPointSize(40);
	
	float x = 0.5;
	glPointSize(60);
	glBegin(GL_POINTS);
	for (int j = 0; j<3; j++)
	{
		for (int i = 0; i<5; i++)
		{
			switch (i)
			{
			case 0:
				glColor3d(x, 0, x); break;
			case 1:
				glColor3d(x, 1, x); break;
			case 2:
				glColor3d(x, x, 0); break;
			case 3:
				glColor3d(0, x, x); break;
			case 4:
				glColor3d(1, x, 1); break;
			}
			glVertex2f(270 - i * 60, 30);
			x = x + 0.2;
		}
		glEnd();
		glFlush();
	}


	

	glBegin(GL_POINTS);
	x = 0.5;
	for (int i = 1; i<4; i++)
	{
		switch (i)
		{
		case 0:
			glColor3d(x, 0, x); break;
		case 1:
			glColor3d(x, 1, x); break;
		case 2:
			glColor3d(0.3, 0.1, 1); break;
		case 3:
			glColor3d(1, 0, 0.3); break;
		case 4:
			glColor3d(1, x, 1); break;
		}
		glVertex2f(270 - i * 60, 90);
		x = x + 0.6;
	}
	glEnd();
	glFlush();


	glBegin(GL_POINTS);
	glColor3d(1, 0, 1);
	glVertex2f(150, 150);
	glEnd();
	glFlush();
}




void reshape(int w, int h)
{
	glViewport(0, 0, (GLsizei)w, (GLsizei)h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, (GLdouble)w, 0.0, (GLdouble)h);
}//end reshape()

int main(int argc, char** argv)
{

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(300, 300);
	glutCreateWindow("Multiple Puncte");
	glutDisplayFunc(display);
	glutReshapeFunc(reshape);
	glutMainLoop();
	return 0;
}
 
 


#include "stdafx.h"
#include <gl/freeglut.h>
void Display(void)
{
glClear(GL_COLOR_BUFFER_BIT);
glColor3f(0, 1, 0);
glBegin(GL_LINES);
// Cadran 1
for (int i = 0; i<20; i++)
{
glVertex3f(0, 0, 0);
glVertex3f(1 - i / 20.0, i / 20.0, 0);
} // Cadran 2
glColor3f(1, 0.4, 0);
for (int i = 0; i<20; i++)
{
glVertex3f(0, 0, 0);
glVertex3f(-1 + i / 20.0, i / 20.0, 0);
} // Cadran 3
glColor3f(1, 0.4, 1);
for (int i = 0; i<20; i++)
{
glVertex3f(0, 0, 0);
glVertex3f(-1 + i / 20.0, -i / 20.0, 0);
}
// Cadran 4
glColor3f(0.8, 0.4, 0.2);
for (int i = 0; i<20; i++)
{
glVertex3f(0, 0, 0);
glVertex3f(1 - i / 20.0, -i / 20.0, 0);
}
glEnd();    glFlush();  glColor3f(0, 0, 1);
}
int main(int argc, char** argv) {
glutInit(&argc, argv);
glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);//se specifica modelul de culoare al ferestrei: un singur buffer si culoare RGB
glutCreateWindow("laborator 3");
glutDisplayFunc(Display);
glutMainLoop();
return 0;
}
 


 
 
#include "stdafx.h"
#include <gl/freeglut.h>
#include<math.h>

void roteste(int p_grade)
{
	glTranslatef(1, 1, 0);
	glRotatef(p_grade, 0.0, 0, 1.0);
	glTranslatef(-1, -1, 0);
}



void OnMouseClick(int button, int state, int x, int y)
{
	if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
	{
		roteste(10);
	}
	if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
	{
		roteste(-10);
	}
}

void rotatie(void)
{
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_POLYGON);//roz
	glColor3f(1, 0, 1);
	glVertex3f(0, 0, 0);
	glVertex3f(1, 0, 0);
	glVertex3f(0, 1, 0);
	glVertex3f(-1, 1 / 2., 0);
	glVertex3f(0, -1, 0);
	glEnd();

	glBegin(GL_TRIANGLES);
	glColor3f(0, 1, 1);
	glVertex3f(0, 1, 0);
	glVertex3f(1, 1, 0);
	glVertex3f(1, 0, 0);
	glEnd();
	glBegin(GL_TRIANGLES);//albastru
	glColor3f(0, 0.5, 1);
	glVertex3f(-1, 1 / 2., 0);
	glVertex3f(-1, 1, 0);
	glVertex3f(0, 1, 0);
	glEnd();
	glBegin(GL_TRIANGLES);//verde
	glColor3f(0, 0.5, .5);
	glVertex3f(-1, 1 / 2., 0);
	glVertex3f(-1, -1, 0);
	glVertex3f(0, -1, 0);
	glEnd();
	glBegin(GL_POLYGON);//galben
	glColor3f(1, 1, 0);
	glVertex3f(0, 0, 0);
	glVertex3f(1, 0, 0);
	glVertex3f(1, -1, 0);
	glVertex3f(0, -1, 0);
	glEnd();
	glFlush();
}
int main(int argc, char** argv)
{

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutCreateWindow("Rotatie_tastatura_mouse");
	glutDisplayFunc(rotatie);
	
	glutMouseFunc(OnMouseClick);
	glutMainLoop();
	return 0;
}
 
 
#include "stdafx.h"
#include <gl/freeglut.h>
#include<math.h>
#include<stdio.h>
#include <stdlib.h>


void init()
{
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glPointSize(50.0);
	glShadeModel(GL_FLAT);
}
void display()
{
	glClear(GL_COLOR_BUFFER_BIT);

	glBegin(GL_TRIANGLES);
	glColor3f(1.0, 0.0, 0.0);
	glVertex2i(1, 0);
	glVertex2i(0, 0);
	glVertex2i(0, 1);
	glEnd();

	glPointSize(1.0);
	glColor3f(1, 1, 1);
	glBegin(GL_POINTS);
	for (int i = 0; i<1000; ++i)
	{
		glVertex3f(cos(2 * 3.14159*i / 1000.0), sin(2 * 3.14159*i / 1000.0), 0);
	}
	glEnd();

	glFlush();
}
int meniu_1, meniu_2, meniu_3, meniu_main;

void meniu_principal(int key)
{
	if (key == 0)
	{
		exit(0);
	}
}

void callback_1(int key)
{
	switch (key)
	{
	case 0:
		printf("Cerc 1\n");
		break;
	case 1:
		printf("Cerc 2\n");
		break;
	}
}

void callback_2(int key)
{
	switch (key)
	{
	case 0:
		printf("Ati selectat dreptunghi 1\n");
		break;
	case 1:
		printf("Ati selectat dreptunghi 2\n");
		break;
	}
}

void callback_3(int key)
{
	switch (key)
	{
	case 0:
		printf("Ati selectat triunghi 1\n");
		break;
	case 1:
		printf("Ati selectat triunghi 2\n");
		break;

	}
}
GLint x = 10;
GLint y = 20;
GLint WindowWidth = 400;
GLint WindowHight = 400;

void mouseHandler(int button, int state, int mouse_x, int mouse_y)
{
	if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
	{
		x = mouse_x;
		y = WindowHight - mouse_y;
		glColor3f(1, 0, 0);
		glBegin(GL_POINTS);
		glVertex2i(x, y);
		printf("x=%d , y=%d \n", x, y);
		glEnd();
		glFlush();
		glClear(GL_COLOR_BUFFER_BIT);
	}
}
int main(int argc, char** argv)
{

	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(400, 400);
	glutInitWindowPosition(400, 100);
	glutCreateWindow("aplicatii");
	init();
	glutMouseFunc(mouseHandler);

	glutDisplayFunc(display);
	meniu_1 = glutCreateMenu(callback_1);
	glutAddMenuEntry("cerc1", 0);
	glutAddMenuEntry("cerc2", 1);
	meniu_2 = glutCreateMenu(callback_2);
	glutAddMenuEntry("dreptunghi1", 0);
	glutAddMenuEntry("dreptunghi2", 1);
	meniu_3 = glutCreateMenu(callback_3);
	glutAddMenuEntry("triunghi1", 0);
	glutAddMenuEntry("triunghi2", 1);

	meniu_main = glutCreateMenu(meniu_principal);
	glutAddSubMenu("cerc", meniu_1);
	glutAddSubMenu("patrat", meniu_2);
	glutAddSubMenu("triunghi", meniu_3);
	glutAddMenuEntry("Exit", 0);
	glutAttachMenu(GLUT_RIGHT_BUTTON);

	glutMainLoop();

	return 0;
}

