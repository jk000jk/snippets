// asd
#include <iostream>
#include <sstream>
#include <cassert>

using namespace std;

typedef struct Node {
    string info;
    int precedenta;
    struct Node *parinte;
    struct Node *left;
    struct Node *right;
} CNode, *PNode;

PNode CreazaNode(const string &x) {
    PNode p = new CNode;
    p->parinte = p->left = p->right = NULL;
    p->info = x;
    return p;
}

bool IsOperator(const string &x) {
    // nu luam in considerare parantezele pt ca afecteaza doar precedenta
    return ((x.length() == 1) &&
            (x[0] == '*' ||
             x[0] == '/' ||
             x[0] == '+' ||
             x[0] == '-'));
}

bool IsLeftParenteza(const string &x) {
    return x == "(";
}

bool IsRightParenteza(const string &x) {
    return x == ")";
}

bool IsOperand(const string &x) {
    int y;
    stringstream ss(x);
    if (ss >> y) return true;
    else return false;
}

int Precedenta(const string &x) {
    assert(IsOperator(x));
    if (x[0] == '*' || x[0] == '/') return 2;
    else return 1;
}

PNode CreazaArbore(const string &exp) {
    PNode root = CreazaNode("0");
    root->precedenta = INT_MIN;

    PNode preOperand = NULL;
    PNode preOperator = root;
    int correction = 0;

    string token;
    stringstream ss(exp);

    while (ss >> token) {
        if (IsOperand(token)) {
            preOperand = CreazaNode(token);
        } else if (IsOperator(token)) {
            PNode p = CreazaNode(token);
            p->precedenta = Precedenta(token) + correction;
            if (p->precedenta > preOperator->precedenta) {
                p->left = preOperand;
                preOperator->right = p;
                p->parinte = preOperator;
            } else {
                preOperator->right = preOperand;
                PNode q = preOperator->parinte;
                while (p->precedenta <= q->precedenta) q = q->parinte;

                p->left = q->right;
                q->right = p;
                p->parinte = q;
            }
            preOperand = NULL;
            preOperator = p;

        } else if (IsLeftParenteza(token)) {
            correction += 2;
        } else if (IsRightParenteza(token)) {
            correction -= 2;
        } else {
            cout << "caracter gresit: " << token << endl;
            break;
        }
    }

    if (preOperand == NULL)
        cout << "expresia nu poate sa se termine cu un operator: "
             << preOperator->info << endl;
    else preOperator->right = preOperand;

    PNode realRoot = root->right;
    delete root;
    if (realRoot) realRoot->parinte = NULL;
    return realRoot;
}

void PostOrderPrint(PNode node) {
    if (node) {
        PostOrderPrint(node->left);
        PostOrderPrint(node->right);
        cout << node->info << " ";
    }
}

void PreOrderPrint(PNode node) {
    if (node) {
        cout << node->info << " ";
        PostOrderPrint(node->left);
        PostOrderPrint(node->right);
    }
}

void InOrderPrint(PNode node) {
    if (node) {
        PostOrderPrint(node->left);
        cout << node->info << " ";
        PostOrderPrint(node->right);
    }
}

int main() {
    // operatori valizi: + - * / ( )
    // doar integeri si spatii intre ex: ( 1 + 2 ) * 3
    // ex. 2 * 3 / ( 2 - 1 ) + 5 * ( 4 - 1 )

    cout << "Exp: ";
    string exp;
    getline(cin, exp);
    cout << endl;

    PNode root = CreazaArbore(exp);
    cout << "Post Order: ";
    PostOrderPrint(root);
    cout << endl;

    cout << "Pre Order: ";
    PreOrderPrint(root);
    cout << endl;

    cout << "In Order: ";
    InOrderPrint(root);
    cout << endl;
}
